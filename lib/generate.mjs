import dotenv from "dotenv";
dotenv.config();

import open from "open";
import fs from "fs-extra";
import path from "path";
import { fileURLToPath } from "url";
import { spawn } from "child_process";
import { GoogleGenerativeAI } from "@google/generative-ai";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const configPath = path.resolve(__dirname, "../.sophiarc.json");
const config = await fs.readJson(configPath).catch(() => ({}));
const defaultPort = config.defaultPort || 3000;

const userPrompt = process.argv.slice(2).join(" ").trim();

const baseFilename =
  userPrompt
    .slice(0, 30)
    .trim()
    .replace(/\s+/g, "-")
    .replace(/[^a-zA-Z0-9-_]/g, "")
    .toLowerCase() || "mock-server";

if (!userPrompt) {
  console.error("Prompt is missing.");
  process.exit(1);
}

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });

(async () => {
  try {
    console.log("Generating mock server...");
    const prompt = `Generate only raw, runnable Express.js code using ESM import syntax (no require or module.exports). Do not include markdown formatting or code blocks. The code should be ready to run as-is. Instruction: ${userPrompt}`;

    const result = await model.generateContent(prompt);
    const response = result.response;
    const reply = response.text();
    console.log("AI response received, processing code...");

    if (!reply || reply.length < 40 || !reply.includes("express")) {
      console.error("Invalid or incomplete code response.");
      return;
    }

    let cleanCode = reply
      .replace(/```[a-z]*\n?/gi, "")
      .replace(/```$/g, "")
      .trim();

    cleanCode = cleanCode
      .replace(
        `const express = require('express');`,
        `import express from 'express';`
      )
      .replace(`module.exports =`, `export default`)
      .replace(`import { open } from 'open';`, `import open from 'open';`)
      .replace(/const port = \d+/, `const port = ${defaultPort}`);

    if (!cleanCode.includes("process.on('SIGINT'")) {
      cleanCode += `\n\n// Keep server running and handle graceful shutdown\nprocess.on('SIGINT', () => {\n  console.log('\\n👋 Shutting down mock server...');\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('\\n👋 Shutting down mock server...');\n  process.exit(0);\n});`;
    }

    const timestamp = Date.now();
    const fileName = `${baseFilename}-${timestamp}.js`;
    const fileDir = path.resolve(
      __dirname,
      "../",
      config.projectDir || "generated"
    );
    const fullPath = path.join(fileDir, fileName);

    await fs.ensureDir(fileDir);
    await fs.writeFile(fullPath, cleanCode);

    // Initialize git repository if it doesn't exist
    await initializeGitRepo(fileDir, fileName, userPrompt);

    console.log(`\nMock server generated successfully!`);
    console.log(`File: ${fileName}`);
    console.log(`Location: ${fullPath}`);

    const routeMatch = cleanCode.match(/app\.get\(['"`](\/[^'"` ]*)['"`]/);
    const routePath = routeMatch ? routeMatch[1] : "/";

    console.log(`\nTo run your mock server:`);
    console.log(`   cd ${path.dirname(fullPath)}`);
    console.log(`   node ${fileName}`);
    console.log(`\nThen visit: http://localhost:${defaultPort}${routePath}`);
    console.log(`Press Ctrl+C to stop the server when running`);

    if (config.editor) {
      await open(fullPath, { app: { name: config.editor } });
    }
  } catch (err) {
    console.error("Error occurred:", err.message);
    if (err.message.includes("API_KEY")) {
      console.error(
        "Please make sure your GEMINI_API_KEY is set in your .env file"
      );
    }
  }
})();

async function initializeGitRepo(projectDir, fileName, userPrompt) {
  try {
    const gitDir = path.join(projectDir, ".git");
    const gitExists = await fs.pathExists(gitDir);

    if (!gitExists) {
      console.log("📦 Initializing git repository...");

      // Initialize git repo
      await executeGitCommand(projectDir, ["init"]);

      // Create .gitignore
      const gitignoreContent = `node_modules/
*.log
.env
.DS_Store
dist/
coverage/
`;
      await fs.writeFile(path.join(projectDir, ".gitignore"), gitignoreContent);

      // Create package.json if it doesn't exist
      const packagePath = path.join(projectDir, "package.json");
      if (!(await fs.pathExists(packagePath))) {
        const packageJson = {
          name: "sophia-generated-servers",
          version: "1.0.0",
          description: "Mock servers generated by Sophia CLI",
          type: "module",
          scripts: {
            start: `node ${fileName}`,
          },
          dependencies: {
            express: "^5.1.0",
          },
        };
        await fs.writeFile(packagePath, JSON.stringify(packageJson, null, 2));
      }

      // Add initial files
      await executeGitCommand(projectDir, ["add", "."]);
      await executeGitCommand(projectDir, [
        "commit",
        "-m",
        "Initial commit: Sophia CLI generated project",
      ]);

      console.log("✅ Git repository initialized");
    }

    // Always commit new generated file
    const shortPrompt =
      userPrompt.slice(0, 50) + (userPrompt.length > 50 ? "..." : "");
    await executeGitCommand(projectDir, ["add", fileName]);
    await executeGitCommand(projectDir, [
      "commit",
      "-m",
      `Generated: ${shortPrompt}`,
    ]);

    console.log(`✅ Committed: ${fileName}`);
  } catch (error) {
    console.log(`⚠️  Git operation failed: ${error.message}`);
  }
}

async function executeGitCommand(cwd, args) {
  return new Promise((resolve, reject) => {
    const child = spawn("git", args, {
      cwd,
      stdio: ["ignore", "pipe", "pipe"],
    });

    let output = "";
    let error = "";

    child.stdout.on("data", data => (output += data.toString()));
    child.stderr.on("data", data => (error += data.toString()));

    child.on("close", code => {
      if (code === 0) {
        resolve(output.trim());
      } else {
        reject(
          new Error(error.trim() || `Git command failed with code ${code}`)
        );
      }
    });

    child.on("error", err => {
      reject(new Error(`Failed to execute git: ${err.message}`));
    });
  });
}
